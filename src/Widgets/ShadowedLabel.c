/* ShadowedLabel.c generated by valac 0.20.1, the Vala compiler
 * generated from ShadowedLabel.vala, do not modify */

/* -*- Mode: vala; indent-tabs-mode: nil; tab-width: 4 -*-*/

#include <glib.h>
#include <glib-object.h>
#include <clutter/clutter.h>
#include <granite.h>
#include <stdlib.h>
#include <string.h>
#include <cairo.h>
#include <pango/pangocairo.h>
#include <pango/pango.h>
#include <float.h>
#include <math.h>


#define TYPE_SHADOWED_LABEL (shadowed_label_get_type ())
#define SHADOWED_LABEL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_SHADOWED_LABEL, ShadowedLabel))
#define SHADOWED_LABEL_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_SHADOWED_LABEL, ShadowedLabelClass))
#define IS_SHADOWED_LABEL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_SHADOWED_LABEL))
#define IS_SHADOWED_LABEL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_SHADOWED_LABEL))
#define SHADOWED_LABEL_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_SHADOWED_LABEL, ShadowedLabelClass))

typedef struct _ShadowedLabel ShadowedLabel;
typedef struct _ShadowedLabelClass ShadowedLabelClass;
typedef struct _ShadowedLabelPrivate ShadowedLabelPrivate;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))

struct _ShadowedLabel {
	ClutterActor parent_instance;
	ShadowedLabelPrivate * priv;
};

struct _ShadowedLabelClass {
	ClutterActorClass parent_class;
};

struct _ShadowedLabelPrivate {
	GraniteDrawingBufferSurface* buffer;
	gchar* _label;
};


static gpointer shadowed_label_parent_class = NULL;

GType shadowed_label_get_type (void) G_GNUC_CONST;
#define SHADOWED_LABEL_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_SHADOWED_LABEL, ShadowedLabelPrivate))
enum  {
	SHADOWED_LABEL_DUMMY_PROPERTY,
	SHADOWED_LABEL_LABEL
};
ShadowedLabel* shadowed_label_new (const gchar* _label);
ShadowedLabel* shadowed_label_construct (GType object_type, const gchar* _label);
static gboolean shadowed_label_draw (ShadowedLabel* self, cairo_t* cr);
static gboolean _shadowed_label_draw_clutter_canvas_draw (ClutterCanvas* _sender, cairo_t* cr, gint width, gint height, gpointer self);
static void __lambda2_ (ShadowedLabel* self);
static void ___lambda2__g_object_notify (GObject* _sender, GParamSpec* pspec, gpointer self);
static void __lambda3_ (ShadowedLabel* self);
static void ___lambda3__g_object_notify (GObject* _sender, GParamSpec* pspec, gpointer self);
void shadowed_label_set_label (ShadowedLabel* self, const gchar* value);
const gchar* shadowed_label_get_label (ShadowedLabel* self);
static void shadowed_label_finalize (GObject* obj);
static void _vala_shadowed_label_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
static void _vala_shadowed_label_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);


static gboolean _shadowed_label_draw_clutter_canvas_draw (ClutterCanvas* _sender, cairo_t* cr, gint width, gint height, gpointer self) {
	gboolean result;
	result = shadowed_label_draw (self, cr);
	return result;
}


static void __lambda2_ (ShadowedLabel* self) {
	ClutterContent* _tmp0_;
	ClutterContent* _tmp1_;
	gfloat _tmp2_;
	gfloat _tmp3_;
	gfloat _tmp4_;
	gfloat _tmp5_;
	_tmp0_ = clutter_actor_get_content ((ClutterActor*) self);
	_tmp1_ = _tmp0_;
	_tmp2_ = clutter_actor_get_width ((ClutterActor*) self);
	_tmp3_ = _tmp2_;
	_tmp4_ = clutter_actor_get_height ((ClutterActor*) self);
	_tmp5_ = _tmp4_;
	clutter_canvas_set_size (G_TYPE_CHECK_INSTANCE_TYPE (_tmp1_, clutter_canvas_get_type ()) ? ((ClutterCanvas*) _tmp1_) : NULL, (gint) _tmp3_, (gint) _tmp5_);
}


static void ___lambda2__g_object_notify (GObject* _sender, GParamSpec* pspec, gpointer self) {
	__lambda2_ (self);
}


static void __lambda3_ (ShadowedLabel* self) {
	ClutterContent* _tmp0_;
	ClutterContent* _tmp1_;
	gfloat _tmp2_;
	gfloat _tmp3_;
	gfloat _tmp4_;
	gfloat _tmp5_;
	_tmp0_ = clutter_actor_get_content ((ClutterActor*) self);
	_tmp1_ = _tmp0_;
	_tmp2_ = clutter_actor_get_width ((ClutterActor*) self);
	_tmp3_ = _tmp2_;
	_tmp4_ = clutter_actor_get_height ((ClutterActor*) self);
	_tmp5_ = _tmp4_;
	clutter_canvas_set_size (G_TYPE_CHECK_INSTANCE_TYPE (_tmp1_, clutter_canvas_get_type ()) ? ((ClutterCanvas*) _tmp1_) : NULL, (gint) _tmp3_, (gint) _tmp5_);
}


static void ___lambda3__g_object_notify (GObject* _sender, GParamSpec* pspec, gpointer self) {
	__lambda3_ (self);
}


ShadowedLabel* shadowed_label_construct (GType object_type, const gchar* _label) {
	ShadowedLabel * self = NULL;
	ClutterCanvas* _tmp0_;
	ClutterCanvas* _tmp1_;
	ClutterContent* _tmp2_;
	ClutterContent* _tmp3_;
	const gchar* _tmp4_;
	g_return_val_if_fail (_label != NULL, NULL);
	self = (ShadowedLabel*) g_object_new (object_type, NULL);
	_tmp0_ = clutter_canvas_new ();
	_tmp1_ = _tmp0_;
	clutter_actor_set_content ((ClutterActor*) self, (ClutterContent*) _tmp1_);
	_g_object_unref0 (_tmp1_);
	_tmp2_ = clutter_actor_get_content ((ClutterActor*) self);
	_tmp3_ = _tmp2_;
	g_signal_connect_object (G_TYPE_CHECK_INSTANCE_TYPE (_tmp3_, clutter_canvas_get_type ()) ? ((ClutterCanvas*) _tmp3_) : NULL, "draw", (GCallback) _shadowed_label_draw_clutter_canvas_draw, self, 0);
	g_signal_connect_object ((GObject*) self, "notify::width", (GCallback) ___lambda2__g_object_notify, self, 0);
	g_signal_connect_object ((GObject*) self, "notify::height", (GCallback) ___lambda3__g_object_notify, self, 0);
	_tmp4_ = _label;
	shadowed_label_set_label (self, _tmp4_);
	return self;
}


ShadowedLabel* shadowed_label_new (const gchar* _label) {
	return shadowed_label_construct (TYPE_SHADOWED_LABEL, _label);
}


static gboolean shadowed_label_draw (ShadowedLabel* self, cairo_t* cr) {
	gboolean result = FALSE;
	cairo_t* _tmp0_;
	cairo_t* _tmp1_;
	cairo_t* _tmp2_;
	gfloat _tmp3_;
	gfloat _tmp4_;
	gfloat _tmp5_;
	gfloat _tmp6_;
	GraniteDrawingBufferSurface* _tmp7_;
	GraniteDrawingBufferSurface* _tmp8_;
	cairo_t* _tmp9_;
	cairo_t* _tmp10_;
	PangoLayout* _tmp11_ = NULL;
	PangoLayout* layout;
	const gchar* _tmp12_;
	const gchar* _tmp13_;
	GraniteDrawingBufferSurface* _tmp14_;
	cairo_t* _tmp15_;
	cairo_t* _tmp16_;
	GraniteDrawingBufferSurface* _tmp17_;
	cairo_t* _tmp18_;
	cairo_t* _tmp19_;
	GraniteDrawingBufferSurface* _tmp20_;
	cairo_t* _tmp21_;
	cairo_t* _tmp22_;
	GraniteDrawingBufferSurface* _tmp23_;
	GraniteDrawingBufferSurface* _tmp24_;
	cairo_t* _tmp25_;
	cairo_t* _tmp26_;
	GraniteDrawingBufferSurface* _tmp27_;
	cairo_t* _tmp28_;
	cairo_t* _tmp29_;
	GraniteDrawingBufferSurface* _tmp30_;
	cairo_t* _tmp31_;
	cairo_t* _tmp32_;
	cairo_t* _tmp33_;
	GraniteDrawingBufferSurface* _tmp34_;
	cairo_surface_t* _tmp35_;
	cairo_surface_t* _tmp36_;
	cairo_t* _tmp37_;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (cr != NULL, FALSE);
	_tmp0_ = cr;
	cairo_set_operator (_tmp0_, CAIRO_OPERATOR_CLEAR);
	_tmp1_ = cr;
	cairo_paint (_tmp1_);
	_tmp2_ = cr;
	cairo_set_operator (_tmp2_, CAIRO_OPERATOR_OVER);
	_tmp3_ = clutter_actor_get_width ((ClutterActor*) self);
	_tmp4_ = _tmp3_;
	_tmp5_ = clutter_actor_get_height ((ClutterActor*) self);
	_tmp6_ = _tmp5_;
	_tmp7_ = granite_drawing_buffer_surface_new ((gint) _tmp4_, (gint) _tmp6_);
	_g_object_unref0 (self->priv->buffer);
	self->priv->buffer = _tmp7_;
	_tmp8_ = self->priv->buffer;
	_tmp9_ = granite_drawing_buffer_surface_get_context (_tmp8_);
	_tmp10_ = _tmp9_;
	_tmp11_ = pango_cairo_create_layout (_tmp10_);
	layout = _tmp11_;
	_tmp12_ = shadowed_label_get_label (self);
	_tmp13_ = _tmp12_;
	pango_layout_set_markup (layout, _tmp13_, -1);
	_tmp14_ = self->priv->buffer;
	_tmp15_ = granite_drawing_buffer_surface_get_context (_tmp14_);
	_tmp16_ = _tmp15_;
	cairo_move_to (_tmp16_, (gdouble) 0, (gdouble) 1);
	_tmp17_ = self->priv->buffer;
	_tmp18_ = granite_drawing_buffer_surface_get_context (_tmp17_);
	_tmp19_ = _tmp18_;
	cairo_set_source_rgba (_tmp19_, (gdouble) 0, (gdouble) 0, (gdouble) 0, (gdouble) 1);
	_tmp20_ = self->priv->buffer;
	_tmp21_ = granite_drawing_buffer_surface_get_context (_tmp20_);
	_tmp22_ = _tmp21_;
	pango_cairo_show_layout (_tmp22_, layout);
	_tmp23_ = self->priv->buffer;
	granite_drawing_buffer_surface_exponential_blur (_tmp23_, 3);
	_tmp24_ = self->priv->buffer;
	_tmp25_ = granite_drawing_buffer_surface_get_context (_tmp24_);
	_tmp26_ = _tmp25_;
	cairo_move_to (_tmp26_, (gdouble) 0, (gdouble) 0);
	_tmp27_ = self->priv->buffer;
	_tmp28_ = granite_drawing_buffer_surface_get_context (_tmp27_);
	_tmp29_ = _tmp28_;
	cairo_set_source_rgba (_tmp29_, (gdouble) 1, (gdouble) 1, (gdouble) 1, (gdouble) 1);
	_tmp30_ = self->priv->buffer;
	_tmp31_ = granite_drawing_buffer_surface_get_context (_tmp30_);
	_tmp32_ = _tmp31_;
	pango_cairo_show_layout (_tmp32_, layout);
	_tmp33_ = cr;
	_tmp34_ = self->priv->buffer;
	_tmp35_ = granite_drawing_buffer_surface_get_surface (_tmp34_);
	_tmp36_ = _tmp35_;
	cairo_set_source_surface (_tmp33_, _tmp36_, (gdouble) 0, (gdouble) 0);
	_tmp37_ = cr;
	cairo_paint (_tmp37_);
	result = TRUE;
	_g_object_unref0 (layout);
	return result;
}


const gchar* shadowed_label_get_label (ShadowedLabel* self) {
	const gchar* result;
	const gchar* _tmp0_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_label;
	result = _tmp0_;
	return result;
}


void shadowed_label_set_label (ShadowedLabel* self, const gchar* value) {
	const gchar* _tmp0_;
	const gchar* _tmp1_;
	const gchar* _tmp2_;
	gchar* _tmp3_;
	PangoFontMap* _tmp4_ = NULL;
	PangoContext* _tmp5_ = NULL;
	PangoContext* _tmp6_;
	PangoLayout* _tmp7_;
	PangoLayout* _tmp8_;
	PangoLayout* l;
	PangoLayout* _tmp9_;
	const gchar* _tmp10_;
	const gchar* _tmp11_;
	PangoRectangle ink = {0};
	PangoRectangle log = {0};
	PangoLayout* _tmp12_;
	PangoRectangle _tmp13_ = {0};
	PangoRectangle _tmp14_ = {0};
	PangoRectangle _tmp15_;
	gint _tmp16_;
	PangoRectangle _tmp17_;
	gint _tmp18_;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_tmp1_ = self->priv->_label;
	if (g_strcmp0 (_tmp0_, _tmp1_) == 0) {
		return;
	}
	_tmp2_ = value;
	_tmp3_ = g_strdup (_tmp2_);
	_g_free0 (self->priv->_label);
	self->priv->_label = _tmp3_;
	_tmp4_ = pango_cairo_font_map_get_default ();
	_tmp5_ = pango_font_map_create_context (_tmp4_);
	_tmp6_ = _tmp5_;
	_tmp7_ = pango_layout_new (_tmp6_);
	_tmp8_ = _tmp7_;
	_g_object_unref0 (_tmp6_);
	l = _tmp8_;
	_tmp9_ = l;
	_tmp10_ = shadowed_label_get_label (self);
	_tmp11_ = _tmp10_;
	pango_layout_set_markup (_tmp9_, _tmp11_, -1);
	_tmp12_ = l;
	pango_layout_get_extents (_tmp12_, &_tmp13_, &_tmp14_);
	ink = _tmp13_;
	log = _tmp14_;
	_tmp15_ = log;
	_tmp16_ = _tmp15_.width;
	clutter_actor_set_width ((ClutterActor*) self, (gfloat) ((_tmp16_ / PANGO_SCALE) + 20));
	_tmp17_ = log;
	_tmp18_ = _tmp17_.height;
	clutter_actor_set_height ((ClutterActor*) self, (gfloat) ((_tmp18_ / PANGO_SCALE) + 6));
	_g_object_unref0 (l);
	g_object_notify ((GObject *) self, "label");
}


static void shadowed_label_class_init (ShadowedLabelClass * klass) {
	shadowed_label_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (ShadowedLabelPrivate));
	G_OBJECT_CLASS (klass)->get_property = _vala_shadowed_label_get_property;
	G_OBJECT_CLASS (klass)->set_property = _vala_shadowed_label_set_property;
	G_OBJECT_CLASS (klass)->finalize = shadowed_label_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), SHADOWED_LABEL_LABEL, g_param_spec_string ("label", "label", "label", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
}


static void shadowed_label_instance_init (ShadowedLabel * self) {
	gchar* _tmp0_;
	self->priv = SHADOWED_LABEL_GET_PRIVATE (self);
	_tmp0_ = g_strdup ("");
	self->priv->_label = _tmp0_;
}


static void shadowed_label_finalize (GObject* obj) {
	ShadowedLabel * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_SHADOWED_LABEL, ShadowedLabel);
	_g_object_unref0 (self->priv->buffer);
	_g_free0 (self->priv->_label);
	G_OBJECT_CLASS (shadowed_label_parent_class)->finalize (obj);
}


/***
    BEGIN LICENSE

    Copyright (C) 2013 Tom Beckmann

    This program is free software: you can redistribute it and/or modify it
    under the terms of the GNU Lesser General Public License version 3, as published
    by the Free Software Foundation.

    This program is distributed in the hope that it will be useful, but
    WITHOUT ANY WARRANTY; without even the implied warranties of
    MERCHANTABILITY, SATISFACTORY QUALITY, or FITNESS FOR A PARTICULAR
    PURPOSE.  See the GNU General Public License for more details.

    You should have received a copy of the GNU General Public License along
    with this program.  If not, see <http://www.gnu.org/licenses/>

    END LICENSE
***/
GType shadowed_label_get_type (void) {
	static volatile gsize shadowed_label_type_id__volatile = 0;
	if (g_once_init_enter (&shadowed_label_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (ShadowedLabelClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) shadowed_label_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (ShadowedLabel), 0, (GInstanceInitFunc) shadowed_label_instance_init, NULL };
		GType shadowed_label_type_id;
		shadowed_label_type_id = g_type_register_static (clutter_actor_get_type (), "ShadowedLabel", &g_define_type_info, 0);
		g_once_init_leave (&shadowed_label_type_id__volatile, shadowed_label_type_id);
	}
	return shadowed_label_type_id__volatile;
}


static void _vala_shadowed_label_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
	ShadowedLabel * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, TYPE_SHADOWED_LABEL, ShadowedLabel);
	switch (property_id) {
		case SHADOWED_LABEL_LABEL:
		g_value_set_string (value, shadowed_label_get_label (self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void _vala_shadowed_label_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec) {
	ShadowedLabel * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, TYPE_SHADOWED_LABEL, ShadowedLabel);
	switch (property_id) {
		case SHADOWED_LABEL_LABEL:
		shadowed_label_set_label (self, g_value_get_string (value));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}



