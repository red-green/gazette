/* Calendar.c generated by valac 0.20.1, the Vala compiler
 * generated from Calendar.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <clutter/clutter.h>
#include <gdata/gdata.h>
#include <stdlib.h>
#include <string.h>


#define TYPE_SERVICE (service_get_type ())
#define SERVICE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_SERVICE, Service))
#define SERVICE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_SERVICE, ServiceClass))
#define IS_SERVICE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_SERVICE))
#define IS_SERVICE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_SERVICE))
#define SERVICE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_SERVICE, ServiceClass))

typedef struct _Service Service;
typedef struct _ServiceClass ServiceClass;
typedef struct _ServicePrivate ServicePrivate;

#define TYPE_CALENDAR (calendar_get_type ())
#define CALENDAR(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_CALENDAR, Calendar))
#define CALENDAR_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_CALENDAR, CalendarClass))
#define IS_CALENDAR(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_CALENDAR))
#define IS_CALENDAR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_CALENDAR))
#define CALENDAR_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_CALENDAR, CalendarClass))

typedef struct _Calendar Calendar;
typedef struct _CalendarClass CalendarClass;
typedef struct _CalendarPrivate CalendarPrivate;

#define TYPE_SHADOWED_LABEL (shadowed_label_get_type ())
#define SHADOWED_LABEL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_SHADOWED_LABEL, ShadowedLabel))
#define SHADOWED_LABEL_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_SHADOWED_LABEL, ShadowedLabelClass))
#define IS_SHADOWED_LABEL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_SHADOWED_LABEL))
#define IS_SHADOWED_LABEL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_SHADOWED_LABEL))
#define SHADOWED_LABEL_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_SHADOWED_LABEL, ShadowedLabelClass))

typedef struct _ShadowedLabel ShadowedLabel;
typedef struct _ShadowedLabelClass ShadowedLabelClass;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))
#define __g_list_free__g_object_unref0_0(var) ((var == NULL) ? NULL : (var = (_g_list_free__g_object_unref0_ (var), NULL)))
#define _g_date_time_unref0(var) ((var == NULL) ? NULL : (var = (g_date_time_unref (var), NULL)))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))

struct _Service {
	ClutterActor parent_instance;
	ServicePrivate * priv;
};

struct _ServiceClass {
	ClutterActorClass parent_class;
	void (*create) (Service* self);
	gboolean (*update) (Service* self);
};

struct _Calendar {
	Service parent_instance;
	CalendarPrivate * priv;
};

struct _CalendarClass {
	ServiceClass parent_class;
};

struct _CalendarPrivate {
	GDataCalendarService* service;
	GDataCalendarEvent* current_event;
	ShadowedLabel* label;
	gchar** accept;
	gint accept_length1;
	gint _accept_size_;
	gchar* time;
	gchar* place;
};


static gpointer calendar_parent_class = NULL;

GType service_get_type (void) G_GNUC_CONST;
GType calendar_get_type (void) G_GNUC_CONST;
GType shadowed_label_get_type (void) G_GNUC_CONST;
#define CALENDAR_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_CALENDAR, CalendarPrivate))
enum  {
	CALENDAR_DUMMY_PROPERTY
};
Calendar* calendar_new (void);
Calendar* calendar_construct (GType object_type);
Service* service_construct (GType object_type, const gchar* _id);
ShadowedLabel* shadowed_label_new (const gchar* _label);
ShadowedLabel* shadowed_label_construct (GType object_type, const gchar* _label);
static void _g_object_unref0_ (gpointer var);
static void _g_list_free__g_object_unref0_ (GList* self);
static gboolean _vala_string_array_contains (gchar** stack, int stack_length, gchar* needle);
static void calendar_real_create (Service* base);
static gboolean calendar_real_update (Service* base);
static void calendar_finalize (GObject* obj);
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


static void _g_object_unref0_ (gpointer var) {
	(var == NULL) ? NULL : (var = (g_object_unref (var), NULL));
}


static void _g_list_free__g_object_unref0_ (GList* self) {
	g_list_foreach (self, (GFunc) _g_object_unref0_, NULL);
	g_list_free (self);
}


static gboolean _vala_string_array_contains (gchar** stack, int stack_length, gchar* needle) {
	int i;
	for (i = 0; i < stack_length; i++) {
		if (g_strcmp0 (stack[i], needle) == 0) {
			return TRUE;
		}
	}
	return FALSE;
}


Calendar* calendar_construct (GType object_type) {
	Calendar * self = NULL;
	ShadowedLabel* _tmp0_;
	ShadowedLabel* _tmp1_;
	ShadowedLabel* _tmp2_;
	GError * _inner_error_ = NULL;
	self = (Calendar*) service_construct (object_type, "calendar");
	_tmp0_ = shadowed_label_new ("");
	g_object_ref_sink (_tmp0_);
	_g_object_unref0 (self->priv->label);
	self->priv->label = _tmp0_;
	_tmp1_ = self->priv->label;
	clutter_actor_set_opacity ((ClutterActor*) _tmp1_, (guint) 0);
	_tmp2_ = self->priv->label;
	clutter_actor_add_child ((ClutterActor*) self, (ClutterActor*) _tmp2_);
	{
		GList* auths;
		GDataAuthorizationDomain* _tmp3_ = NULL;
		GDataAuthorizationDomain* _tmp4_;
		GList* _tmp5_;
		GDataClientLoginAuthorizer* _tmp6_;
		GDataClientLoginAuthorizer* auth;
		GDataClientLoginAuthorizer* _tmp7_;
		GDataClientLoginAuthorizer* _tmp8_;
		GDataCalendarService* _tmp9_;
		GDataCalendarService* _tmp10_;
		GDataCalendarQuery* _tmp11_;
		GDataCalendarQuery* query;
		GDataCalendarQuery* _tmp12_;
		GDateTime* _tmp13_;
		GDateTime* _tmp14_;
		gint64 _tmp15_ = 0LL;
		GDataCalendarQuery* _tmp16_;
		GDataCalendarQuery* _tmp17_;
		GDataCalendarQuery* _tmp18_;
		GDataCalendarQuery* _tmp19_;
		GDataCalendarQuery* _tmp20_;
		GDataCalendarService* _tmp21_;
		GDataFeed* _tmp22_ = NULL;
		GDataFeed* calendars;
		GDataFeed* _tmp23_;
		GList* _tmp24_ = NULL;
		GDataCalendarEvent* _tmp63_;
		GDataCalendarEvent* _tmp64_;
		GList* _tmp65_ = NULL;
		gconstpointer _tmp66_ = NULL;
		gint64 _tmp67_;
		gint64 _tmp68_;
		GDateTime* _tmp69_;
		GDateTime* _tmp70_;
		gchar* _tmp71_ = NULL;
		gboolean _tmp72_ = FALSE;
		GDataCalendarEvent* _tmp73_;
		GList* _tmp74_ = NULL;
		guint _tmp75_ = 0U;
		gboolean _tmp81_;
		auths = NULL;
		_tmp3_ = gdata_calendar_service_get_primary_authorization_domain ();
		_tmp4_ = _g_object_ref0 (_tmp3_);
		auths = g_list_append (auths, _tmp4_);
		_tmp5_ = auths;
		_tmp6_ = gdata_client_login_authorizer_new_for_authorization_domains ("weather", _tmp5_);
		auth = _tmp6_;
		_tmp7_ = auth;
		gdata_client_login_authorizer_authenticate (_tmp7_, "loginname", "password", NULL, &_inner_error_);
		if (_inner_error_ != NULL) {
			_g_object_unref0 (auth);
			__g_list_free__g_object_unref0_0 (auths);
			goto __catch2_g_error;
		}
		_tmp8_ = auth;
		_tmp9_ = gdata_calendar_service_new ((GDataAuthorizer*) _tmp8_);
		_g_object_unref0 (self->priv->service);
		self->priv->service = _tmp9_;
		_tmp10_ = self->priv->service;
		if (_tmp10_ == NULL) {
			_g_object_unref0 (auth);
			__g_list_free__g_object_unref0_0 (auths);
			return self;
		}
		_tmp11_ = gdata_calendar_query_new (NULL);
		query = _tmp11_;
		_tmp12_ = query;
		_tmp13_ = g_date_time_new_now_local ();
		_tmp14_ = _tmp13_;
		_tmp15_ = g_date_time_to_unix (_tmp14_);
		gdata_calendar_query_set_start_min (_tmp12_, _tmp15_);
		_g_date_time_unref0 (_tmp14_);
		_tmp16_ = query;
		g_object_set ((GDataQuery*) _tmp16_, "is-strict", TRUE, NULL);
		_tmp17_ = query;
		gdata_calendar_query_set_future_events (_tmp17_, TRUE);
		_tmp18_ = query;
		gdata_calendar_query_set_order_by (_tmp18_, "starttime");
		_tmp19_ = query;
		gdata_calendar_query_set_sort_order (_tmp19_, "ascending");
		_tmp20_ = query;
		gdata_query_set_max_results ((GDataQuery*) _tmp20_, (guint) 1);
		_tmp21_ = self->priv->service;
		_tmp22_ = gdata_calendar_service_query_all_calendars (_tmp21_, NULL, NULL, NULL, NULL, &_inner_error_);
		calendars = _tmp22_;
		if (_inner_error_ != NULL) {
			_g_object_unref0 (query);
			_g_object_unref0 (auth);
			__g_list_free__g_object_unref0_0 (auths);
			goto __catch2_g_error;
		}
		_tmp23_ = calendars;
		_tmp24_ = gdata_feed_get_entries (_tmp23_);
		{
			GList* calendar_collection = NULL;
			GList* calendar_it = NULL;
			calendar_collection = _tmp24_;
			for (calendar_it = calendar_collection; calendar_it != NULL; calendar_it = calendar_it->next) {
				GDataEntry* _tmp25_;
				GDataEntry* calendar = NULL;
				_tmp25_ = _g_object_ref0 ((GDataEntry*) calendar_it->data);
				calendar = _tmp25_;
				{
					GDataEntry* _tmp26_;
					const gchar* _tmp27_;
					const gchar* _tmp28_;
					gchar** _tmp29_;
					gint _tmp29__length1;
					GDataCalendarService* _tmp30_;
					GDataEntry* _tmp31_;
					GDataCalendarQuery* _tmp32_;
					GDataFeed* _tmp33_ = NULL;
					GDataFeed* res;
					GDataFeed* _tmp34_;
					GList* _tmp35_ = NULL;
					gconstpointer _tmp36_ = NULL;
					GDataEntry* _tmp37_;
					GDataCalendarEvent* _tmp38_;
					GDataCalendarEvent* new_event;
					GDataEntry* _tmp39_;
					const gchar* _tmp40_;
					const gchar* _tmp41_;
					GDataFeed* _tmp42_;
					GList* _tmp43_ = NULL;
					gboolean _tmp48_ = FALSE;
					GDataCalendarEvent* _tmp49_;
					gboolean _tmp60_;
					_tmp26_ = calendar;
					_tmp27_ = gdata_entry_get_title (_tmp26_);
					_tmp28_ = _tmp27_;
					_tmp29_ = self->priv->accept;
					_tmp29__length1 = self->priv->accept_length1;
					if (!_vala_string_array_contains (_tmp29_, _tmp29__length1, _tmp28_)) {
						_g_object_unref0 (calendar);
						continue;
					}
					_tmp30_ = self->priv->service;
					_tmp31_ = calendar;
					_tmp32_ = query;
					_tmp33_ = gdata_calendar_service_query_events (_tmp30_, G_TYPE_CHECK_INSTANCE_TYPE (_tmp31_, gdata_calendar_calendar_get_type ()) ? ((GDataCalendarCalendar*) _tmp31_) : NULL, (GDataQuery*) _tmp32_, NULL, NULL, NULL, &_inner_error_);
					res = _tmp33_;
					if (_inner_error_ != NULL) {
						_g_object_unref0 (calendar);
						_g_object_unref0 (calendars);
						_g_object_unref0 (query);
						_g_object_unref0 (auth);
						__g_list_free__g_object_unref0_0 (auths);
						goto __catch2_g_error;
					}
					_tmp34_ = res;
					_tmp35_ = gdata_feed_get_entries (_tmp34_);
					_tmp36_ = g_list_nth_data (_tmp35_, (guint) 0);
					_tmp37_ = (GDataEntry*) _tmp36_;
					_tmp38_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_TYPE (_tmp37_, gdata_calendar_event_get_type ()) ? ((GDataCalendarEvent*) _tmp37_) : NULL);
					new_event = _tmp38_;
					_tmp39_ = calendar;
					_tmp40_ = gdata_entry_get_title (_tmp39_);
					_tmp41_ = _tmp40_;
					g_print ("CALENDAR: %s\n", _tmp41_);
					_tmp42_ = res;
					_tmp43_ = gdata_feed_get_entries (_tmp42_);
					{
						GList* ev_collection = NULL;
						GList* ev_it = NULL;
						ev_collection = _tmp43_;
						for (ev_it = ev_collection; ev_it != NULL; ev_it = ev_it->next) {
							GDataEntry* _tmp44_;
							GDataEntry* ev = NULL;
							_tmp44_ = _g_object_ref0 ((GDataEntry*) ev_it->data);
							ev = _tmp44_;
							{
								GDataEntry* _tmp45_;
								const gchar* _tmp46_;
								const gchar* _tmp47_;
								_tmp45_ = ev;
								_tmp46_ = gdata_entry_get_title (_tmp45_);
								_tmp47_ = _tmp46_;
								g_print ("\tEVENT: %s\n", _tmp47_);
								_g_object_unref0 (ev);
							}
						}
					}
					_tmp49_ = self->priv->current_event;
					if (_tmp49_ == NULL) {
						_tmp48_ = TRUE;
					} else {
						GDataCalendarEvent* _tmp50_;
						GList* _tmp51_ = NULL;
						gconstpointer _tmp52_ = NULL;
						gint64 _tmp53_;
						gint64 _tmp54_;
						GDataCalendarEvent* _tmp55_;
						GList* _tmp56_ = NULL;
						gconstpointer _tmp57_ = NULL;
						gint64 _tmp58_;
						gint64 _tmp59_;
						_tmp50_ = new_event;
						_tmp51_ = gdata_calendar_event_get_times (_tmp50_);
						_tmp52_ = g_list_nth_data (_tmp51_, (guint) 0);
						_tmp53_ = gdata_gd_when_get_start_time ((GDataGDWhen*) _tmp52_);
						_tmp54_ = _tmp53_;
						_tmp55_ = self->priv->current_event;
						_tmp56_ = gdata_calendar_event_get_times (_tmp55_);
						_tmp57_ = g_list_nth_data (_tmp56_, (guint) 0);
						_tmp58_ = gdata_gd_when_get_start_time ((GDataGDWhen*) _tmp57_);
						_tmp59_ = _tmp58_;
						_tmp48_ = _tmp54_ < _tmp59_;
					}
					_tmp60_ = _tmp48_;
					if (_tmp60_) {
						GDataCalendarEvent* _tmp61_;
						GDataCalendarEvent* _tmp62_;
						_tmp61_ = new_event;
						_tmp62_ = _g_object_ref0 (_tmp61_);
						_g_object_unref0 (self->priv->current_event);
						self->priv->current_event = _tmp62_;
					}
					_g_object_unref0 (new_event);
					_g_object_unref0 (res);
					_g_object_unref0 (calendar);
				}
			}
		}
		_tmp63_ = self->priv->current_event;
		if (_tmp63_ == NULL) {
			_g_object_unref0 (calendars);
			_g_object_unref0 (query);
			_g_object_unref0 (auth);
			__g_list_free__g_object_unref0_0 (auths);
			return self;
		}
		_tmp64_ = self->priv->current_event;
		_tmp65_ = gdata_calendar_event_get_times (_tmp64_);
		_tmp66_ = g_list_nth_data (_tmp65_, (guint) 0);
		_tmp67_ = gdata_gd_when_get_start_time ((GDataGDWhen*) _tmp66_);
		_tmp68_ = _tmp67_;
		_tmp69_ = g_date_time_new_from_unix_local (_tmp68_);
		_tmp70_ = _tmp69_;
		_tmp71_ = g_date_time_format (_tmp70_, "%H:%M");
		_g_free0 (self->priv->time);
		self->priv->time = _tmp71_;
		_g_date_time_unref0 (_tmp70_);
		_tmp73_ = self->priv->current_event;
		_tmp74_ = gdata_calendar_event_get_places (_tmp73_);
		_tmp75_ = g_list_length (_tmp74_);
		if (_tmp75_ > ((guint) 0)) {
			GDataCalendarEvent* _tmp76_;
			GList* _tmp77_ = NULL;
			gconstpointer _tmp78_ = NULL;
			const gchar* _tmp79_;
			const gchar* _tmp80_;
			_tmp76_ = self->priv->current_event;
			_tmp77_ = gdata_calendar_event_get_places (_tmp76_);
			_tmp78_ = g_list_nth_data (_tmp77_, (guint) 0);
			_tmp79_ = gdata_gd_where_get_label ((GDataGDWhere*) _tmp78_);
			_tmp80_ = _tmp79_;
			_tmp72_ = _tmp80_ != NULL;
		} else {
			_tmp72_ = FALSE;
		}
		_tmp81_ = _tmp72_;
		if (_tmp81_) {
			GDataCalendarEvent* _tmp82_;
			GList* _tmp83_ = NULL;
			gconstpointer _tmp84_ = NULL;
			const gchar* _tmp85_;
			const gchar* _tmp86_;
			gchar* _tmp87_;
			_tmp82_ = self->priv->current_event;
			_tmp83_ = gdata_calendar_event_get_places (_tmp82_);
			_tmp84_ = g_list_nth_data (_tmp83_, (guint) 0);
			_tmp85_ = gdata_gd_where_get_label ((GDataGDWhere*) _tmp84_);
			_tmp86_ = _tmp85_;
			_tmp87_ = g_strconcat ("@", _tmp86_, NULL);
			_g_free0 (self->priv->place);
			self->priv->place = _tmp87_;
		}
		_g_object_unref0 (calendars);
		_g_object_unref0 (query);
		_g_object_unref0 (auth);
		__g_list_free__g_object_unref0_0 (auths);
	}
	goto __finally2;
	__catch2_g_error:
	{
		GError* e = NULL;
		GError* _tmp88_;
		const gchar* _tmp89_;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp88_ = e;
		_tmp89_ = _tmp88_->message;
		g_warning ("Calendar.vala:62: %s", _tmp89_);
		_g_error_free0 (e);
	}
	__finally2:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
	return self;
}


Calendar* calendar_new (void) {
	return calendar_construct (TYPE_CALENDAR);
}


static void calendar_real_create (Service* base) {
	Calendar * self;
	const gchar* _tmp0_;
	gchar* _tmp1_;
	gchar* _tmp2_;
	gchar* _tmp3_;
	gchar* _tmp4_;
	gchar* _tmp5_;
	gchar* _tmp6_;
	GDataCalendarEvent* _tmp7_;
	const gchar* _tmp8_;
	const gchar* _tmp9_;
	gchar* _tmp10_;
	gchar* _tmp11_;
	const gchar* _tmp12_;
	gchar* _tmp13_;
	gchar* _tmp14_;
	gchar* _tmp15_;
	gchar* _tmp16_;
	ShadowedLabel* _tmp17_;
	ShadowedLabel* _tmp18_;
	ShadowedLabel* label;
	self = (Calendar*) base;
	_tmp0_ = self->priv->time;
	_tmp1_ = g_strconcat ("<span face='wallstate' font='42'>i</span>" "<span face='Raleway' weight='100' font='72'> ", _tmp0_, NULL);
	_tmp2_ = _tmp1_;
	_tmp3_ = g_strconcat (_tmp2_, " </span>\n", NULL);
	_tmp4_ = _tmp3_;
	_tmp5_ = g_strconcat (_tmp4_, "<span face='Open Sans Light' font='24'> ", NULL);
	_tmp6_ = _tmp5_;
	_tmp7_ = self->priv->current_event;
	_tmp8_ = gdata_entry_get_title ((GDataEntry*) _tmp7_);
	_tmp9_ = _tmp8_;
	_tmp10_ = g_strconcat (_tmp6_, _tmp9_, NULL);
	_tmp11_ = _tmp10_;
	_tmp12_ = self->priv->place;
	_tmp13_ = g_strconcat (_tmp11_, _tmp12_, NULL);
	_tmp14_ = _tmp13_;
	_tmp15_ = g_strconcat (_tmp14_, " </span>", NULL);
	_tmp16_ = _tmp15_;
	_tmp17_ = shadowed_label_new (_tmp16_);
	g_object_ref_sink (_tmp17_);
	_tmp18_ = _tmp17_;
	_g_free0 (_tmp16_);
	_g_free0 (_tmp14_);
	_g_free0 (_tmp11_);
	_g_free0 (_tmp6_);
	_g_free0 (_tmp4_);
	_g_free0 (_tmp2_);
	label = _tmp18_;
	clutter_actor_add_child ((ClutterActor*) self, (ClutterActor*) label);
	_g_object_unref0 (label);
}


static gboolean calendar_real_update (Service* base) {
	Calendar * self;
	gboolean result = FALSE;
	self = (Calendar*) base;
	result = TRUE;
	return result;
}


static void calendar_class_init (CalendarClass * klass) {
	calendar_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (CalendarPrivate));
	SERVICE_CLASS (klass)->create = calendar_real_create;
	SERVICE_CLASS (klass)->update = calendar_real_update;
	G_OBJECT_CLASS (klass)->finalize = calendar_finalize;
}


static void calendar_instance_init (Calendar * self) {
	gchar* _tmp0_;
	gchar** _tmp1_ = NULL;
	gchar* _tmp2_;
	self->priv = CALENDAR_GET_PRIVATE (self);
	self->priv->current_event = NULL;
	_tmp0_ = g_strdup ("");
	_tmp1_ = g_new0 (gchar*, 1 + 1);
	_tmp1_[0] = _tmp0_;
	self->priv->accept = _tmp1_;
	self->priv->accept_length1 = 1;
	self->priv->_accept_size_ = self->priv->accept_length1;
	_tmp2_ = g_strdup ("");
	self->priv->place = _tmp2_;
}


static void calendar_finalize (GObject* obj) {
	Calendar * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_CALENDAR, Calendar);
	_g_object_unref0 (self->priv->service);
	_g_object_unref0 (self->priv->current_event);
	_g_object_unref0 (self->priv->label);
	self->priv->accept = (_vala_array_free (self->priv->accept, self->priv->accept_length1, (GDestroyNotify) g_free), NULL);
	_g_free0 (self->priv->time);
	_g_free0 (self->priv->place);
	G_OBJECT_CLASS (calendar_parent_class)->finalize (obj);
}


GType calendar_get_type (void) {
	static volatile gsize calendar_type_id__volatile = 0;
	if (g_once_init_enter (&calendar_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (CalendarClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) calendar_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (Calendar), 0, (GInstanceInitFunc) calendar_instance_init, NULL };
		GType calendar_type_id;
		calendar_type_id = g_type_register_static (TYPE_SERVICE, "Calendar", &g_define_type_info, 0);
		g_once_init_leave (&calendar_type_id__volatile, calendar_type_id);
	}
	return calendar_type_id__volatile;
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}



