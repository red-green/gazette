/* Service.c generated by valac 0.20.1, the Vala compiler
 * generated from Service.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <clutter/clutter.h>
#include <float.h>
#include <math.h>
#include <stdlib.h>
#include <string.h>
#include <granite.h>
#include <glib/gi18n-lib.h>


#define TYPE_SERVICE (service_get_type ())
#define SERVICE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_SERVICE, Service))
#define SERVICE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_SERVICE, ServiceClass))
#define IS_SERVICE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_SERVICE))
#define IS_SERVICE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_SERVICE))
#define SERVICE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_SERVICE, ServiceClass))

typedef struct _Service Service;
typedef struct _ServiceClass ServiceClass;
typedef struct _ServicePrivate ServicePrivate;
#define _g_free0(var) (var = (g_free (var), NULL))

#define TYPE_GLOBAL_SETTINGS (global_settings_get_type ())
#define GLOBAL_SETTINGS(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_GLOBAL_SETTINGS, GlobalSettings))
#define GLOBAL_SETTINGS_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_GLOBAL_SETTINGS, GlobalSettingsClass))
#define IS_GLOBAL_SETTINGS(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_GLOBAL_SETTINGS))
#define IS_GLOBAL_SETTINGS_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_GLOBAL_SETTINGS))
#define GLOBAL_SETTINGS_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_GLOBAL_SETTINGS, GlobalSettingsClass))

typedef struct _GlobalSettings GlobalSettings;
typedef struct _GlobalSettingsClass GlobalSettingsClass;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))

#define TYPE_SHADOWED_LABEL (shadowed_label_get_type ())
#define SHADOWED_LABEL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_SHADOWED_LABEL, ShadowedLabel))
#define SHADOWED_LABEL_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_SHADOWED_LABEL, ShadowedLabelClass))
#define IS_SHADOWED_LABEL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_SHADOWED_LABEL))
#define IS_SHADOWED_LABEL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_SHADOWED_LABEL))
#define SHADOWED_LABEL_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_SHADOWED_LABEL, ShadowedLabelClass))

typedef struct _ShadowedLabel ShadowedLabel;
typedef struct _ShadowedLabelClass ShadowedLabelClass;

struct _Service {
	ClutterActor parent_instance;
	ServicePrivate * priv;
};

struct _ServiceClass {
	ClutterActorClass parent_class;
	void (*create) (Service* self);
	gboolean (*update) (Service* self);
};

struct _ServicePrivate {
	guint timeout;
	gfloat start_x;
	gfloat start_y;
	gboolean held;
	gchar* _id;
};


static gpointer service_parent_class = NULL;

GType service_get_type (void) G_GNUC_CONST;
#define SERVICE_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_SERVICE, ServicePrivate))
enum  {
	SERVICE_DUMMY_PROPERTY,
	SERVICE_ID
};
#define SERVICE_UPDATE_INTERVAL ((1000 * 60) * 30)
Service* service_construct (GType object_type, const gchar* _id);
static void service_set_id (Service* self, const gchar* value);
static gboolean service_real_button_press_event (ClutterActor* base, ClutterButtonEvent* event);
static gboolean service_long_held (Service* self);
static gboolean _service_long_held_gsource_func (gpointer self);
static gboolean service_intercept (Service* self, ClutterEvent* event);
static gboolean _service_intercept_clutter_actor_captured_event (ClutterActor* _sender, ClutterEvent* event, gpointer self);
static void service_clear_timeout (Service* self);
GType global_settings_get_type (void) G_GNUC_CONST;
GlobalSettings* global_settings_get_default (void);
gchar** global_settings_get_services_enabled (GlobalSettings* self, int* result_length1);
static gchar** _vala_array_dup2 (gchar** self, int length);
const gchar* service_get_id (Service* self);
void global_settings_set_services_enabled (GlobalSettings* self, gchar** value, int value_length1);
gboolean service_load (Service* self);
void service_create (Service* self);
gboolean service_update (Service* self);
void service_display (Service* self);
GType shadowed_label_get_type (void) G_GNUC_CONST;
ShadowedLabel* service_get_reload_label (Service* self, const gchar* service_name);
#define textcolor "black"
ShadowedLabel* shadowed_label_new (const gchar* _label);
ShadowedLabel* shadowed_label_construct (GType object_type, const gchar* _label);
static gboolean _service_update_clutter_actor_button_release_event (ClutterActor* _sender, ClutterButtonEvent* event, gpointer self);
static void service_real_create (Service* self);
static gboolean service_real_update (Service* self);
gchar* service_ellipsize (const gchar* s, gint max_length);
static void service_finalize (GObject* obj);
static void _vala_service_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
static void _vala_service_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);


Service* service_construct (GType object_type, const gchar* _id) {
	Service * self = NULL;
	const gchar* _tmp0_;
	g_return_val_if_fail (_id != NULL, NULL);
	self = (Service*) g_object_new (object_type, NULL);
	_tmp0_ = _id;
	service_set_id (self, _tmp0_);
	clutter_actor_set_opacity ((ClutterActor*) self, (guint) 0);
	clutter_actor_set_reactive ((ClutterActor*) self, TRUE);
	g_object_set ((ClutterActor*) self, "scale-gravity", CLUTTER_GRAVITY_NORTH_WEST, NULL);
	return self;
}


static gboolean _service_long_held_gsource_func (gpointer self) {
	gboolean result;
	result = service_long_held (self);
	return result;
}


static gboolean _service_intercept_clutter_actor_captured_event (ClutterActor* _sender, ClutterEvent* event, gpointer self) {
	gboolean result;
	result = service_intercept (self, event);
	return result;
}


static gboolean service_real_button_press_event (ClutterActor* base, ClutterButtonEvent* event) {
	Service * self;
	gboolean result = FALSE;
	ClutterSettings* _tmp0_ = NULL;
	gint _tmp1_ = 0;
	gint _tmp2_;
	guint _tmp3_ = 0U;
	ClutterButtonEvent _tmp4_;
	gfloat _tmp5_;
	gfloat _tmp6_;
	gfloat _tmp7_;
	ClutterButtonEvent _tmp8_;
	gfloat _tmp9_;
	gfloat _tmp10_;
	gfloat _tmp11_;
	ClutterStage* _tmp12_ = NULL;
	self = (Service*) base;
	g_return_val_if_fail (event != NULL, FALSE);
	_tmp0_ = clutter_settings_get_default ();
	g_object_get (_tmp0_, "long-press-duration", &_tmp1_, NULL);
	_tmp2_ = _tmp1_;
	_tmp3_ = g_timeout_add_full (G_PRIORITY_DEFAULT, (guint) _tmp2_, _service_long_held_gsource_func, g_object_ref (self), g_object_unref);
	self->priv->timeout = _tmp3_;
	_tmp4_ = *event;
	_tmp5_ = _tmp4_.x;
	_tmp6_ = clutter_actor_get_x ((ClutterActor*) self);
	_tmp7_ = _tmp6_;
	self->priv->start_x = _tmp5_ - _tmp7_;
	_tmp8_ = *event;
	_tmp9_ = _tmp8_.y;
	_tmp10_ = clutter_actor_get_y ((ClutterActor*) self);
	_tmp11_ = _tmp10_;
	self->priv->start_y = _tmp9_ - _tmp11_;
	_tmp12_ = clutter_actor_get_stage ((ClutterActor*) self);
	g_signal_connect_object ((ClutterActor*) _tmp12_, "captured-event", (GCallback) _service_intercept_clutter_actor_captured_event, self, 0);
	result = FALSE;
	return result;
}


static gboolean service_long_held (Service* self) {
	gboolean result = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	self->priv->held = TRUE;
	clutter_actor_animate ((ClutterActor*) self, (gulong) CLUTTER_EASE_IN_OUT_BACK, (guint) 300, "scale-x", 0.8f, "scale-y", 0.8f, NULL);
	result = FALSE;
	return result;
}


static gchar** _vala_array_dup2 (gchar** self, int length) {
	gchar** result;
	int i;
	result = g_new0 (gchar*, length + 1);
	for (i = 0; i < length; i++) {
		gchar* _tmp0_;
		_tmp0_ = g_strdup (self[i]);
		result[i] = _tmp0_;
	}
	return result;
}


static glong string_strnlen (gchar* str, glong maxlen) {
	glong result = 0L;
	gchar* _tmp0_;
	glong _tmp1_;
	gchar* _tmp2_ = NULL;
	gchar* end;
	gchar* _tmp3_;
	_tmp0_ = str;
	_tmp1_ = maxlen;
	_tmp2_ = memchr (_tmp0_, 0, (gsize) _tmp1_);
	end = _tmp2_;
	_tmp3_ = end;
	if (_tmp3_ == NULL) {
		glong _tmp4_;
		_tmp4_ = maxlen;
		result = _tmp4_;
		return result;
	} else {
		gchar* _tmp5_;
		gchar* _tmp6_;
		_tmp5_ = end;
		_tmp6_ = str;
		result = (glong) (_tmp5_ - _tmp6_);
		return result;
	}
}


static gchar* string_substring (const gchar* self, glong offset, glong len) {
	gchar* result = NULL;
	glong string_length = 0L;
	gboolean _tmp0_ = FALSE;
	glong _tmp1_;
	gboolean _tmp3_;
	glong _tmp9_;
	glong _tmp15_;
	glong _tmp18_;
	glong _tmp19_;
	glong _tmp20_;
	glong _tmp21_;
	glong _tmp22_;
	gchar* _tmp23_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp1_ = offset;
	if (_tmp1_ >= ((glong) 0)) {
		glong _tmp2_;
		_tmp2_ = len;
		_tmp0_ = _tmp2_ >= ((glong) 0);
	} else {
		_tmp0_ = FALSE;
	}
	_tmp3_ = _tmp0_;
	if (_tmp3_) {
		glong _tmp4_;
		glong _tmp5_;
		glong _tmp6_ = 0L;
		_tmp4_ = offset;
		_tmp5_ = len;
		_tmp6_ = string_strnlen ((gchar*) self, _tmp4_ + _tmp5_);
		string_length = _tmp6_;
	} else {
		gint _tmp7_;
		gint _tmp8_;
		_tmp7_ = strlen (self);
		_tmp8_ = _tmp7_;
		string_length = (glong) _tmp8_;
	}
	_tmp9_ = offset;
	if (_tmp9_ < ((glong) 0)) {
		glong _tmp10_;
		glong _tmp11_;
		glong _tmp12_;
		_tmp10_ = string_length;
		_tmp11_ = offset;
		offset = _tmp10_ + _tmp11_;
		_tmp12_ = offset;
		g_return_val_if_fail (_tmp12_ >= ((glong) 0), NULL);
	} else {
		glong _tmp13_;
		glong _tmp14_;
		_tmp13_ = offset;
		_tmp14_ = string_length;
		g_return_val_if_fail (_tmp13_ <= _tmp14_, NULL);
	}
	_tmp15_ = len;
	if (_tmp15_ < ((glong) 0)) {
		glong _tmp16_;
		glong _tmp17_;
		_tmp16_ = string_length;
		_tmp17_ = offset;
		len = _tmp16_ - _tmp17_;
	}
	_tmp18_ = offset;
	_tmp19_ = len;
	_tmp20_ = string_length;
	g_return_val_if_fail ((_tmp18_ + _tmp19_) <= _tmp20_, NULL);
	_tmp21_ = offset;
	_tmp22_ = len;
	_tmp23_ = g_strndup (((gchar*) self) + _tmp21_, (gsize) _tmp22_);
	result = _tmp23_;
	return result;
}


static gboolean service_intercept (Service* self, ClutterEvent* event) {
	gboolean result = FALSE;
	ClutterEvent* _tmp0_;
	ClutterEventType _tmp1_ = 0;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (event != NULL, FALSE);
	_tmp0_ = event;
	_tmp1_ = clutter_event_type (_tmp0_);
	switch (_tmp1_) {
		case CLUTTER_SCROLL:
		{
			gdouble scale_x_value;
			gdouble scale_y_value;
			gdouble _tmp2_ = 0.0;
			gdouble _tmp3_ = 0.0;
			ClutterEvent* _tmp4_;
			ClutterScrollDirection _tmp5_ = 0;
			scale_x_value = 0.0;
			scale_y_value = (gdouble) 0;
			clutter_actor_get_scale ((ClutterActor*) self, &_tmp2_, &_tmp3_);
			scale_x_value = _tmp2_;
			scale_y_value = _tmp3_;
			_tmp4_ = event;
			_tmp5_ = clutter_event_get_scroll_direction (_tmp4_);
			switch (_tmp5_) {
				case CLUTTER_SCROLL_UP:
				{
					gdouble _tmp6_;
					gdouble _tmp7_;
					_tmp6_ = scale_x_value;
					_tmp7_ = scale_y_value;
					clutter_actor_animate ((ClutterActor*) self, (gulong) CLUTTER_EASE_IN_OUT_BACK, (guint) 100, "scale-x", _tmp6_ * 1.1, "scale-y", _tmp7_ * 1.1, NULL);
					break;
				}
				case CLUTTER_SCROLL_DOWN:
				{
					gdouble _tmp8_;
					gdouble _tmp9_;
					_tmp8_ = scale_x_value;
					_tmp9_ = scale_y_value;
					clutter_actor_animate ((ClutterActor*) self, (gulong) CLUTTER_EASE_IN_OUT_BACK, (guint) 100, "scale-x", _tmp8_ * 0.9, "scale-y", _tmp9_ * 0.9, NULL);
					break;
				}
				default:
				break;
			}
			result = TRUE;
			return result;
		}
		case CLUTTER_BUTTON_RELEASE:
		{
			ClutterStage* _tmp10_ = NULL;
			guint _tmp11_ = 0U;
			gboolean _tmp12_;
			GlobalSettings* _tmp13_ = NULL;
			GlobalSettings* _tmp14_;
			gchar** _tmp15_;
			gint _tmp15__length1;
			gchar** _tmp16_;
			gint _tmp16__length1;
			gchar** _tmp17_;
			gint _tmp17__length1;
			gchar** _tmp18_;
			gint _tmp18__length1;
			gchar** list;
			gint list_length1;
			gint _list_size_;
			_tmp10_ = clutter_actor_get_stage ((ClutterActor*) self);
			g_signal_parse_name ("captured-event", clutter_actor_get_type (), &_tmp11_, NULL, FALSE);
			g_signal_handlers_disconnect_matched ((ClutterActor*) _tmp10_, G_SIGNAL_MATCH_ID | G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA, _tmp11_, 0, NULL, (GCallback) _service_intercept_clutter_actor_captured_event, self);
			_tmp12_ = self->priv->held;
			if (!_tmp12_) {
				service_clear_timeout (self);
				result = FALSE;
				return result;
			}
			_tmp13_ = global_settings_get_default ();
			_tmp14_ = _tmp13_;
			_tmp15_ = global_settings_get_services_enabled (_tmp14_, &_tmp15__length1);
			_tmp16_ = _tmp15_;
			_tmp16__length1 = _tmp15__length1;
			_tmp17_ = (_tmp16_ != NULL) ? _vala_array_dup2 (_tmp16_, _tmp16__length1) : ((gpointer) _tmp16_);
			_tmp17__length1 = _tmp16__length1;
			_tmp18_ = _tmp17_;
			_tmp18__length1 = _tmp17__length1;
			_g_object_unref0 (_tmp14_);
			list = _tmp18_;
			list_length1 = _tmp18__length1;
			_list_size_ = list_length1;
			{
				gint i;
				i = 0;
				{
					gboolean _tmp19_;
					_tmp19_ = TRUE;
					while (TRUE) {
						gboolean _tmp20_;
						gint _tmp22_;
						gchar** _tmp23_;
						gint _tmp23__length1;
						gboolean _tmp24_ = FALSE;
						gchar** _tmp25_;
						gint _tmp25__length1;
						gint _tmp26_;
						const gchar* _tmp27_;
						gint _tmp28_;
						gint _tmp29_;
						const gchar* _tmp30_;
						gint _tmp31_;
						gint _tmp32_;
						gboolean _tmp42_;
						_tmp20_ = _tmp19_;
						if (!_tmp20_) {
							gint _tmp21_;
							_tmp21_ = i;
							i = _tmp21_ + 1;
						}
						_tmp19_ = FALSE;
						_tmp22_ = i;
						_tmp23_ = list;
						_tmp23__length1 = list_length1;
						if (!(_tmp22_ < _tmp23__length1)) {
							break;
						}
						_tmp25_ = list;
						_tmp25__length1 = list_length1;
						_tmp26_ = i;
						_tmp27_ = _tmp25_[_tmp26_];
						_tmp28_ = strlen (_tmp27_);
						_tmp29_ = _tmp28_;
						_tmp30_ = self->priv->_id;
						_tmp31_ = strlen (_tmp30_);
						_tmp32_ = _tmp31_;
						if (_tmp29_ >= _tmp32_) {
							gchar** _tmp33_;
							gint _tmp33__length1;
							gint _tmp34_;
							const gchar* _tmp35_;
							const gchar* _tmp36_;
							gint _tmp37_;
							gint _tmp38_;
							gchar* _tmp39_ = NULL;
							gchar* _tmp40_;
							const gchar* _tmp41_;
							_tmp33_ = list;
							_tmp33__length1 = list_length1;
							_tmp34_ = i;
							_tmp35_ = _tmp33_[_tmp34_];
							_tmp36_ = self->priv->_id;
							_tmp37_ = strlen (_tmp36_);
							_tmp38_ = _tmp37_;
							_tmp39_ = string_substring (_tmp35_, (glong) 0, (glong) _tmp38_);
							_tmp40_ = _tmp39_;
							_tmp41_ = self->priv->_id;
							_tmp24_ = g_strcmp0 (_tmp40_, _tmp41_) == 0;
							_g_free0 (_tmp40_);
						} else {
							_tmp24_ = FALSE;
						}
						_tmp42_ = _tmp24_;
						if (_tmp42_) {
							gchar** _tmp43_;
							gint _tmp43__length1;
							gint _tmp44_;
							const gchar* _tmp45_;
							gchar* _tmp46_;
							gchar* _tmp47_;
							gfloat _tmp48_;
							gfloat _tmp49_;
							gchar* _tmp50_ = NULL;
							gchar* _tmp51_;
							gchar* _tmp52_;
							gchar* _tmp53_;
							gchar* _tmp54_;
							gchar* _tmp55_;
							gfloat _tmp56_;
							gfloat _tmp57_;
							gchar* _tmp58_ = NULL;
							gchar* _tmp59_;
							gchar* _tmp60_;
							gchar* _tmp61_;
							GlobalSettings* _tmp62_ = NULL;
							GlobalSettings* _tmp63_;
							gchar** _tmp64_;
							gint _tmp64__length1;
							_tmp43_ = list;
							_tmp43__length1 = list_length1;
							_tmp44_ = i;
							_tmp45_ = self->priv->_id;
							_tmp46_ = g_strconcat (_tmp45_, ":", NULL);
							_tmp47_ = _tmp46_;
							_tmp48_ = clutter_actor_get_x ((ClutterActor*) self);
							_tmp49_ = _tmp48_;
							_tmp50_ = g_strdup_printf ("%i", (gint) _tmp49_);
							_tmp51_ = _tmp50_;
							_tmp52_ = g_strconcat (_tmp47_, _tmp51_, NULL);
							_tmp53_ = _tmp52_;
							_tmp54_ = g_strconcat (_tmp53_, ",", NULL);
							_tmp55_ = _tmp54_;
							_tmp56_ = clutter_actor_get_y ((ClutterActor*) self);
							_tmp57_ = _tmp56_;
							_tmp58_ = g_strdup_printf ("%i", (gint) _tmp57_);
							_tmp59_ = _tmp58_;
							_tmp60_ = g_strconcat (_tmp55_, _tmp59_, NULL);
							_g_free0 (_tmp43_[_tmp44_]);
							_tmp43_[_tmp44_] = _tmp60_;
							_tmp61_ = _tmp43_[_tmp44_];
							_g_free0 (_tmp59_);
							_g_free0 (_tmp55_);
							_g_free0 (_tmp53_);
							_g_free0 (_tmp51_);
							_g_free0 (_tmp47_);
							_tmp62_ = global_settings_get_default ();
							_tmp63_ = _tmp62_;
							_tmp64_ = list;
							_tmp64__length1 = list_length1;
							global_settings_set_services_enabled (_tmp63_, _tmp64_, _tmp64__length1);
							_g_object_unref0 (_tmp63_);
							break;
						}
					}
				}
			}
			clutter_actor_animate ((ClutterActor*) self, (gulong) CLUTTER_EASE_IN_OUT_BACK, (guint) 300, "scale-x", 1.0f, "scale-y", 1.0f, NULL);
			service_clear_timeout (self);
			result = TRUE;
			list = (_vala_array_free (list, list_length1, (GDestroyNotify) g_free), NULL);
			return result;
		}
		case CLUTTER_MOTION:
		{
			gboolean _tmp65_;
			gfloat ex = 0.0F;
			gfloat ey = 0.0F;
			ClutterEvent* _tmp66_;
			gfloat _tmp67_ = 0.0F;
			gfloat _tmp68_ = 0.0F;
			gfloat _tmp69_;
			gfloat _tmp70_;
			gfloat _tmp71_ = 0.0F;
			gfloat _tmp72_;
			gfloat _tmp73_;
			gfloat _tmp74_ = 0.0F;
			_tmp65_ = self->priv->held;
			if (!_tmp65_) {
				result = FALSE;
				return result;
			}
			_tmp66_ = event;
			clutter_event_get_coords (_tmp66_, &_tmp67_, &_tmp68_);
			ex = _tmp67_;
			ey = _tmp68_;
			_tmp69_ = ex;
			_tmp70_ = self->priv->start_x;
			_tmp71_ = floorf (_tmp69_ - _tmp70_);
			clutter_actor_set_x ((ClutterActor*) self, _tmp71_);
			_tmp72_ = ey;
			_tmp73_ = self->priv->start_y;
			_tmp74_ = floorf (_tmp72_ - _tmp73_);
			clutter_actor_set_y ((ClutterActor*) self, _tmp74_);
			result = TRUE;
			return result;
		}
		default:
		break;
	}
	result = FALSE;
	return result;
}


static void service_clear_timeout (Service* self) {
	guint _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->timeout;
	if (_tmp0_ > ((guint) 0)) {
		guint _tmp1_;
		_tmp1_ = self->priv->timeout;
		g_source_remove (_tmp1_);
		self->priv->timeout = (guint) 0;
	}
	self->priv->held = FALSE;
}


gboolean service_load (Service* self) {
	gboolean result = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	service_create (self);
	service_update (self);
	service_display (self);
	result = FALSE;
	return result;
}


static gboolean _service_update_clutter_actor_button_release_event (ClutterActor* _sender, ClutterButtonEvent* event, gpointer self) {
	gboolean result;
	result = service_update (self);
	return result;
}


ShadowedLabel* service_get_reload_label (Service* self, const gchar* service_name) {
	ShadowedLabel* result = NULL;
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_;
	gchar* _tmp2_;
	const gchar* _tmp3_;
	gchar* _tmp4_;
	gchar* _tmp5_;
	gchar* _tmp6_;
	gchar* _tmp7_;
	const gchar* _tmp8_ = NULL;
	gchar* _tmp9_;
	gchar* _tmp10_;
	gchar* _tmp11_;
	gchar* _tmp12_;
	ShadowedLabel* _tmp13_;
	ShadowedLabel* _tmp14_;
	ShadowedLabel* reload;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (service_name != NULL, NULL);
	_tmp0_ = _ ("Could not retrieve ");
	_tmp1_ = g_strconcat ("<span color='" textcolor "' face='Open Sans Light' font='16'>", _tmp0_, NULL);
	_tmp2_ = _tmp1_;
	_tmp3_ = service_name;
	_tmp4_ = g_strconcat (_tmp2_, _tmp3_, NULL);
	_tmp5_ = _tmp4_;
	_tmp6_ = g_strconcat (_tmp5_, ",\n", NULL);
	_tmp7_ = _tmp6_;
	_tmp8_ = _ ("click here to try again");
	_tmp9_ = g_strconcat (_tmp7_, _tmp8_, NULL);
	_tmp10_ = _tmp9_;
	_tmp11_ = g_strconcat (_tmp10_, ".</span>", NULL);
	_tmp12_ = _tmp11_;
	_tmp13_ = shadowed_label_new (_tmp12_);
	g_object_ref_sink (_tmp13_);
	_tmp14_ = _tmp13_;
	_g_free0 (_tmp12_);
	_g_free0 (_tmp10_);
	_g_free0 (_tmp7_);
	_g_free0 (_tmp5_);
	_g_free0 (_tmp2_);
	reload = _tmp14_;
	clutter_actor_set_reactive ((ClutterActor*) reload, TRUE);
	g_signal_connect_object ((ClutterActor*) reload, "button-release-event", (GCallback) _service_update_clutter_actor_button_release_event, self, 0);
	result = reload;
	return result;
}


static void service_real_create (Service* self) {
	g_critical ("Type `%s' does not implement abstract method `service_create'", g_type_name (G_TYPE_FROM_INSTANCE (self)));
	return;
}


void service_create (Service* self) {
	g_return_if_fail (self != NULL);
	SERVICE_GET_CLASS (self)->create (self);
}


static gboolean service_real_update (Service* self) {
	g_critical ("Type `%s' does not implement abstract method `service_update'", g_type_name (G_TYPE_FROM_INSTANCE (self)));
	return FALSE;
}


gboolean service_update (Service* self) {
	g_return_val_if_fail (self != NULL, FALSE);
	return SERVICE_GET_CLASS (self)->update (self);
}


void service_display (Service* self) {
	g_return_if_fail (self != NULL);
	clutter_actor_animate ((ClutterActor*) self, (gulong) CLUTTER_LINEAR, (guint) 400, "opacity", 255, NULL);
}


static gint string_index_of_nth_char (const gchar* self, glong c) {
	gint result = 0;
	glong _tmp0_;
	gchar* _tmp1_ = NULL;
	g_return_val_if_fail (self != NULL, 0);
	_tmp0_ = c;
	_tmp1_ = g_utf8_offset_to_pointer (self, _tmp0_);
	result = (gint) (_tmp1_ - ((gchar*) self));
	return result;
}


gchar* service_ellipsize (const gchar* s, gint max_length) {
	gchar* result = NULL;
	const gchar* _tmp0_;
	gchar* _tmp1_;
	gchar* ret;
	const gchar* _tmp2_;
	gint _tmp3_;
	gint _tmp4_;
	gint _tmp5_;
	const gchar* _tmp13_;
	g_return_val_if_fail (s != NULL, NULL);
	_tmp0_ = s;
	_tmp1_ = g_strdup (_tmp0_);
	ret = _tmp1_;
	_tmp2_ = ret;
	_tmp3_ = strlen (_tmp2_);
	_tmp4_ = _tmp3_;
	_tmp5_ = max_length;
	if (_tmp4_ > _tmp5_) {
		const gchar* _tmp6_;
		const gchar* _tmp7_;
		gint _tmp8_;
		gint _tmp9_ = 0;
		gchar* _tmp10_ = NULL;
		gchar* _tmp11_;
		gchar* _tmp12_;
		_tmp6_ = ret;
		_tmp7_ = ret;
		_tmp8_ = max_length;
		_tmp9_ = string_index_of_nth_char (_tmp7_, (glong) (_tmp8_ - 3));
		_tmp10_ = string_substring (_tmp6_, (glong) 0, (glong) _tmp9_);
		_tmp11_ = _tmp10_;
		_tmp12_ = g_strconcat (_tmp11_, "...", NULL);
		_g_free0 (ret);
		ret = _tmp12_;
		_g_free0 (_tmp11_);
	}
	_tmp13_ = ret;
	g_debug ("Service.vala:132: %s", _tmp13_);
	result = ret;
	return result;
}


const gchar* service_get_id (Service* self) {
	const gchar* result;
	const gchar* _tmp0_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_id;
	result = _tmp0_;
	return result;
}


static void service_set_id (Service* self, const gchar* value) {
	const gchar* _tmp0_;
	gchar* _tmp1_;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (self->priv->_id);
	self->priv->_id = _tmp1_;
	g_object_notify ((GObject *) self, "id");
}


static void service_class_init (ServiceClass * klass) {
	service_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (ServicePrivate));
	CLUTTER_ACTOR_CLASS (klass)->button_press_event = service_real_button_press_event;
	SERVICE_CLASS (klass)->create = service_real_create;
	SERVICE_CLASS (klass)->update = service_real_update;
	G_OBJECT_CLASS (klass)->get_property = _vala_service_get_property;
	G_OBJECT_CLASS (klass)->set_property = _vala_service_set_property;
	G_OBJECT_CLASS (klass)->finalize = service_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), SERVICE_ID, g_param_spec_string ("id", "id", "id", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
}


static void service_instance_init (Service * self) {
	self->priv = SERVICE_GET_PRIVATE (self);
	self->priv->timeout = (guint) 0;
	self->priv->held = FALSE;
}


static void service_finalize (GObject* obj) {
	Service * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_SERVICE, Service);
	_g_free0 (self->priv->_id);
	G_OBJECT_CLASS (service_parent_class)->finalize (obj);
}


GType service_get_type (void) {
	static volatile gsize service_type_id__volatile = 0;
	if (g_once_init_enter (&service_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (ServiceClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) service_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (Service), 0, (GInstanceInitFunc) service_instance_init, NULL };
		GType service_type_id;
		service_type_id = g_type_register_static (clutter_actor_get_type (), "Service", &g_define_type_info, G_TYPE_FLAG_ABSTRACT);
		g_once_init_leave (&service_type_id__volatile, service_type_id);
	}
	return service_type_id__volatile;
}


static void _vala_service_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
	Service * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, TYPE_SERVICE, Service);
	switch (property_id) {
		case SERVICE_ID:
		g_value_set_string (value, service_get_id (self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void _vala_service_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec) {
	Service * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, TYPE_SERVICE, Service);
	switch (property_id) {
		case SERVICE_ID:
		service_set_id (self, g_value_get_string (value));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}



